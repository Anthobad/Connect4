#include "gamelogic.h"
#include "ui.h"
#include <termios.h>
#include <unistd.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#define MAX_MOVES (ROWS * COLS)

typedef struct {
	int row;
	int col;
	char player;
} Move;

static Move history[MAX_MOVES];
static int move_count = 0;
static int current_index = 0;

static struct termios orig_tio;
static int raw_enabled = 0;

static void reset_history(void) {
	move_count = 0;
	current_index = 0;
}

static void record_move(int row, int col, char player) {
	if (current_index < move_count) {
		move_count = current_index;
	}
	if (move_count < MAX_MOVES) {
		history[move_count].row = row;
		history[move_count].col = col;
		history[move_count].player = player;
		move_count++;
		current_index = move_count;
	}
}

static int undo_move(Board* G) {
	if (current_index == 0)
		return 0;
	current_index--;
	Move m = history[current_index];
	G->cells[m.row][m.col] = EMPTY;
	G->current = m.player;
	return 1;
}

static int redo_move(Board* G) {
	if (current_index == move_count)
		return 0;
	Move m = history[current_index];
	G->cells[m.row][m.col] = m.player;
	current_index++;
	if (m.player == 'A')
		G->current = 'B';
	else
		G->current = 'A';
	return 1;
}

static void enable_raw(void) {
	if (raw_enabled)
		return;
	struct termios tio;
	tcgetattr(STDIN_FILENO, &orig_tio);
	tio = orig_tio;
	tio.c_lflag &= ~(ICANON | ECHO);
	tio.c_cc[VMIN] = 1;
	tio.c_cc[VTIME] = 0;
	tcsetattr(STDIN_FILENO, TCSANOW, &tio);
	raw_enabled = 1;
}

static void disable_raw(void) {
	if (!raw_enabled)
		return;
	tcsetattr(STDIN_FILENO, TCSANOW, &orig_tio);
	raw_enabled = 0;
}

enum {
	KEY_NONE = 0,
	KEY_LEFT = 1000,
	KEY_RIGHT,
	KEY_ENTER
};

static int read_key(void) {
	unsigned char b;
	if (read(STDIN_FILENO, &b, 1) != 1)
		return KEY_NONE;
	if (b == '\r' || b == '\n')
		return KEY_ENTER;
	if (b == 0x1B) {
		unsigned char seq[2];
		if (read(STDIN_FILENO, &seq[0], 1) != 1) return KEY_NONE;
		if (read(STDIN_FILENO, &seq[1], 1) != 1) return KEY_NONE;
		if (seq[0] == '[') {
			if (seq[1] == 'D') return KEY_LEFT;
			if (seq[1] == 'C') return KEY_RIGHT;
		}
		return KEY_NONE;
	}
	return (int)b;
}

static void switch_player(Board* G) {
	if (G->current == 'A')
		G->current = 'B';
	else
		G->current = 'A';
}

static int do_drop(Board* G, int col0, int use_anim, int anim_ms) {
	if (use_anim) {
		UiOptions opt;
		opt.use_color = 1;
		opt.delay_ms = anim_ms;
		return ui_drop_with_animation(G, col0, G->current, &opt);
	} else {
		return game_drop(G, col0, G->current);
	}
}

static void draw_with_cursor(const Board* G, int use_color, int sel_col) {
	ui_clear_screen();
	ui_print_board(G, use_color);
	printf("\nUse \xE2\x86\x90/\xE2\x86\x92 to move, Enter to drop, u=undo, r=redo, p=again, q=quit\n");
	printf("Selected column: %d\n", sel_col + 1);
	fflush(stdout);
}

static int turn_loop(Board* G, int* sel_col, int use_anim, int anim_ms) {
	while (1) {
		int k = read_key();
		if (k == KEY_LEFT) {
			if (*sel_col > 0) *sel_col -= 1; else *sel_col = COLS - 1;
			draw_with_cursor(G, 1, *sel_col);
		} else if (k == KEY_RIGHT) {
			if (*sel_col < COLS - 1) *sel_col += 1; else *sel_col = 0;
			draw_with_cursor(G, 1, *sel_col);
		} else if (k == KEY_ENTER) {
			int row = do_drop(G, *sel_col, use_anim, anim_ms);
			if (row == -1) {
				draw_with_cursor(G, 1, *sel_col);
				continue;
			}
			record_move(row, *sel_col, G->current);
			if (!use_anim) {
				draw_with_cursor(G, 1, *sel_col);
			}
			if (checkWin(G, row, *sel_col, G->current)) {
				printf("Player %c wins!\n", G->current);
				return 1;
			}
			if (checkDraw(G)) {
				printf("It's a draw!\n");
				return 1;
			}
			switch_player(G);
			draw_with_cursor(G, 1, *sel_col);
		} else if (k == 'u' || k == 'U') {
			if (undo_move(G)) {
				draw_with_cursor(G, 1, *sel_col);
			}
		} else if (k == 'r' || k == 'R') {
			if (redo_move(G)) {
				draw_with_cursor(G, 1, *sel_col);
			}
		} else if (k == 'q' || k == 'Q') {
			return -1;
		} else if (k == 'p' || k == 'P') {
			return 2;
		}
	}
}

static int play_again_prompt_raw(void) {
	printf("\nPlay again? y/n\n");
	fflush(stdout);
	while (1) {
		int k = read_key();
		if (k == 'y' || k == 'Y') return 1;
		if (k == 'n' || k == 'N') return 0;
	}
}

int main(int argc, char** argv) {
	int use_anim = 1;
	int anim_ms = 110;
	if (argc > 1 && strcmp(argv[1], "--no-anim") == 0)
		use_anim = 0;

	atexit(disable_raw);
	enable_raw();

	while (1) {
		Board G;
		initializeBoard(&G);
		reset_history();
		int sel_col = 0;
		draw_with_cursor(&G, 1, sel_col);

		int game_over = 0;
		while (!game_over) {
			int r = turn_loop(&G, &sel_col, use_anim, anim_ms);
			if (r == -1) {
				printf("Goodbye!\n");
				return 0;
			}
			if (r == 2) {
				break;
			}
			if (r == 1) {
				game_over = 1;
			}
		}

		if (game_over) {
			if (!play_again_prompt_raw()) {
				printf("Thanks for playing!\n");
				return 0;
			}
		}
	}
}
